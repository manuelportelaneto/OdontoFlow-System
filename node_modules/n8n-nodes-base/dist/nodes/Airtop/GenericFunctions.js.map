{"version":3,"sources":["../../../nodes/Airtop/GenericFunctions.ts"],"sourcesContent":["import { NodeApiError, type IExecuteFunctions, type INode, type IDataObject } from 'n8n-workflow';\nimport { NodeOperationError } from 'n8n-workflow';\n\nimport { SESSION_MODE } from './actions/common/fields';\nimport type { TScrollingMode } from './constants';\nimport {\n\tERROR_MESSAGES,\n\tDEFAULT_TIMEOUT_MINUTES,\n\tMIN_TIMEOUT_MINUTES,\n\tMAX_TIMEOUT_MINUTES,\n\tSESSION_STATUS,\n\tOPERATION_TIMEOUT,\n} from './constants';\nimport { apiRequest } from './transport';\nimport type { IAirtopResponse, IAirtopSessionResponse } from './transport/types';\n\n/**\n * Validate a required string field\n * @param this - The execution context\n * @param index - The index of the node\n * @param field - The field to validate\n * @param fieldName - The name of the field\n */\nexport function validateRequiredStringField(\n\tthis: IExecuteFunctions,\n\tindex: number,\n\tfield: string,\n\tfieldName: string,\n) {\n\tlet value = this.getNodeParameter(field, index, '') as string;\n\tvalue = (value || '').trim();\n\tconst errorMessage = ERROR_MESSAGES.REQUIRED_PARAMETER.replace('{{field}}', fieldName);\n\n\tif (!value) {\n\t\tthrow new NodeOperationError(this.getNode(), errorMessage, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn value;\n}\n\n/**\n * Validate the session ID parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated session ID\n */\nexport function validateSessionId(this: IExecuteFunctions, index: number) {\n\tlet sessionId = this.getNodeParameter('sessionId', index, '') as string;\n\tsessionId = (sessionId || '').trim();\n\n\tif (!sessionId) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.SESSION_ID_REQUIRED, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn sessionId;\n}\n\n/**\n * Validate the session ID and window ID parameters\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated session ID and window ID parameters\n */\nexport function validateSessionAndWindowId(this: IExecuteFunctions, index: number) {\n\tlet sessionId = this.getNodeParameter('sessionId', index, '') as string;\n\tlet windowId = this.getNodeParameter('windowId', index, '') as string;\n\tsessionId = (sessionId || '').trim();\n\twindowId = (windowId || '').trim();\n\n\tif (!sessionId) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.SESSION_ID_REQUIRED, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\tif (!windowId) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.WINDOW_ID_REQUIRED, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn {\n\t\tsessionId,\n\t\twindowId,\n\t};\n}\n\n/**\n * Validate the profile name parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated profile name\n */\nexport function validateProfileName(this: IExecuteFunctions, index: number) {\n\tlet profileName = this.getNodeParameter('profileName', index) as string;\n\tprofileName = (profileName || '').trim();\n\n\tif (!profileName) {\n\t\treturn profileName;\n\t}\n\n\tif (!/^[a-zA-Z0-9-]+$/.test(profileName)) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.PROFILE_NAME_INVALID, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn profileName;\n}\n\n/**\n * Validate the timeout minutes parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated timeout minutes\n */\nexport function validateTimeoutMinutes(this: IExecuteFunctions, index: number) {\n\tconst timeoutMinutes = this.getNodeParameter(\n\t\t'timeoutMinutes',\n\t\tindex,\n\t\tDEFAULT_TIMEOUT_MINUTES,\n\t) as number;\n\n\tif (timeoutMinutes < MIN_TIMEOUT_MINUTES || timeoutMinutes > MAX_TIMEOUT_MINUTES) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.TIMEOUT_MINUTES_INVALID, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn timeoutMinutes;\n}\n\n/**\n * Validate the URL parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated URL\n */\nexport function validateUrl(this: IExecuteFunctions, index: number) {\n\tlet url = this.getNodeParameter('url', index) as string;\n\turl = (url || '').trim();\n\n\tif (!url) {\n\t\treturn '';\n\t}\n\n\tif (!url.startsWith('http')) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.URL_INVALID, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn url;\n}\n\n/**\n * Validate the Proxy configuration\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated proxy configuration\n */\nexport function validateProxy(this: IExecuteFunctions, index: number) {\n\tconst proxyParam = this.getNodeParameter('proxy', index, '') as\n\t\t| 'none'\n\t\t| 'integrated'\n\t\t| 'proxyUrl';\n\tconst proxyConfig = this.getNodeParameter('proxyConfig', index, '') as {\n\t\tcountry: string;\n\t\tsticky: boolean;\n\t};\n\tconst isConfigEmpty = Object.keys(proxyConfig).length === 0;\n\n\tif (proxyParam === 'integrated') {\n\t\treturn {\n\t\t\tproxy: isConfigEmpty ? true : { ...proxyConfig },\n\t\t};\n\t}\n\n\t// handle custom proxy configuration\n\tif (proxyParam === 'proxyUrl') {\n\t\treturn {\n\t\t\tproxy: validateRequiredStringField.call(this, index, 'proxyUrl', 'Proxy URL'),\n\t\t};\n\t}\n\n\treturn {\n\t\tproxy: false,\n\t};\n}\n\n/**\n * Validate the scrollBy amount parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @param parameterName - The name of the parameter\n * @returns The validated scrollBy amount\n */\nexport function validateScrollByAmount(\n\tthis: IExecuteFunctions,\n\tindex: number,\n\tparameterName: string,\n) {\n\tconst regex = /^(?:-?\\d{1,3}(?:%|px))$/;\n\tconst scrollBy = this.getNodeParameter(parameterName, index, {}) as {\n\t\txAxis?: string;\n\t\tyAxis?: string;\n\t};\n\n\tif (!scrollBy?.xAxis && !scrollBy?.yAxis) {\n\t\treturn {};\n\t}\n\n\tconst allAxisValid = [scrollBy.xAxis, scrollBy.yAxis]\n\t\t.filter(Boolean)\n\t\t.every((axis) => regex.test(axis ?? ''));\n\n\tif (!allAxisValid) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.SCROLL_BY_AMOUNT_INVALID, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn scrollBy;\n}\n\n/**\n * Validate the scroll mode parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @returns Scroll mode\n * @throws Error if the scroll mode or scroll parameters are invalid\n */\nexport function validateScrollingMode(this: IExecuteFunctions, index: number): TScrollingMode {\n\tconst scrollingMode = this.getNodeParameter(\n\t\t'scrollingMode',\n\t\tindex,\n\t\t'automatic',\n\t) as TScrollingMode;\n\n\tconst scrollToEdge = this.getNodeParameter('scrollToEdge.edgeValues', index, {}) as {\n\t\txAxis?: string;\n\t\tyAxis?: string;\n\t};\n\tconst scrollBy = this.getNodeParameter('scrollBy.scrollValues', index, {}) as {\n\t\txAxis?: string;\n\t\tyAxis?: string;\n\t};\n\n\tif (scrollingMode !== 'manual') {\n\t\treturn scrollingMode;\n\t}\n\n\t// validate manual scroll parameters\n\tconst emptyScrollBy = !scrollBy.xAxis && !scrollBy.yAxis;\n\tconst emptyScrollToEdge = !scrollToEdge.xAxis && !scrollToEdge.yAxis;\n\n\tif (emptyScrollBy && emptyScrollToEdge) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.SCROLL_MODE_INVALID, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn scrollingMode;\n}\n\n/**\n * Validate the screen resolution parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The validated screen resolution\n */\nexport function validateScreenResolution(this: IExecuteFunctions, index: number) {\n\tlet screenResolution = this.getNodeParameter('screenResolution', index, '') as string;\n\tscreenResolution = (screenResolution || '').trim().toLowerCase();\n\tconst regex = /^\\d{3,4}x\\d{3,4}$/; // Expected format: 1280x720\n\n\tif (!screenResolution) {\n\t\treturn '';\n\t}\n\n\tif (!regex.test(screenResolution)) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.SCREEN_RESOLUTION_INVALID, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn screenResolution;\n}\n\n/**\n * Validate the save profile on termination parameter\n * @param this - The execution context\n * @param index - The index of the node\n * @param profileName - The profile name\n * @returns The validated save profile on termination\n */\nexport function validateSaveProfileOnTermination(\n\tthis: IExecuteFunctions,\n\tindex: number,\n\tprofileName: string,\n) {\n\tconst saveProfileOnTermination = this.getNodeParameter(\n\t\t'saveProfileOnTermination',\n\t\tindex,\n\t\tfalse,\n\t) as boolean;\n\n\tif (saveProfileOnTermination && !profileName) {\n\t\tthrow new NodeOperationError(this.getNode(), ERROR_MESSAGES.PROFILE_NAME_REQUIRED, {\n\t\t\titemIndex: index,\n\t\t});\n\t}\n\n\treturn saveProfileOnTermination;\n}\n\n/**\n * Check if there is an error in the API response and throw NodeApiError\n * @param node - The node instance\n * @param response - The response from the API\n */\nexport function validateAirtopApiResponse(node: INode, response: IAirtopResponse) {\n\tif (response?.errors?.length) {\n\t\tconst errorMessage = response.errors.map((error) => error.message).join('\\n');\n\t\tthrow new NodeApiError(node, {\n\t\t\tmessage: errorMessage,\n\t\t});\n\t}\n}\n\n/**\n * Convert a screenshot from the API response to a binary buffer\n * @param screenshot - The screenshot from the API response\n * @returns The processed screenshot\n */\nexport function convertScreenshotToBinary(screenshot: { dataUrl: string }): Buffer {\n\tconst base64Data = screenshot.dataUrl.replace('data:image/jpeg;base64,', '');\n\tconst buffer = Buffer.from(base64Data, 'base64');\n\treturn buffer;\n}\n\n/**\n * Check if a new session should be created\n * @param this - The execution context\n * @param index - The index of the node\n * @returns True if a new session should be created, false otherwise\n */\nexport function shouldCreateNewSession(this: IExecuteFunctions, index: number) {\n\tconst sessionMode = this.getNodeParameter('sessionMode', index) as string;\n\treturn Boolean(sessionMode && sessionMode === SESSION_MODE.NEW);\n}\n\n/**\n * Create a new session and wait until the session is ready\n * @param this - The execution context\n * @param parameters - The parameters for the session\n * @returns The session ID\n */\nexport async function createSession(\n\tthis: IExecuteFunctions,\n\tparameters: IDataObject,\n\ttimeout = OPERATION_TIMEOUT,\n): Promise<{ sessionId: string }> {\n\t// Request session creation\n\tconst response = (await apiRequest.call(\n\t\tthis,\n\t\t'POST',\n\t\t'/sessions',\n\t\tparameters,\n\t)) as IAirtopSessionResponse;\n\tconst sessionId = response?.data?.id;\n\n\tif (!sessionId) {\n\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\tmessage: 'Failed to create session',\n\t\t\tcode: 500,\n\t\t});\n\t}\n\n\t// Poll until the session is ready or timeout is reached\n\tlet sessionStatus = response?.data?.status;\n\tconst startTime = Date.now();\n\n\twhile (sessionStatus !== SESSION_STATUS.RUNNING) {\n\t\tif (Date.now() - startTime > timeout) {\n\t\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\t\tmessage: ERROR_MESSAGES.TIMEOUT_REACHED,\n\t\t\t\tcode: 500,\n\t\t\t});\n\t\t}\n\t\tawait new Promise((resolve) => setTimeout(resolve, 1000));\n\t\tconst sessionStatusResponse = (await apiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\t`/sessions/${sessionId}`,\n\t\t)) as IAirtopSessionResponse;\n\t\tsessionStatus = sessionStatusResponse.data.status;\n\t}\n\n\treturn { sessionId };\n}\n\n/**\n * Create a new session and window\n * @param this - The execution context\n * @param index - The index of the node\n * @returns The session ID and window ID\n */\nexport async function createSessionAndWindow(\n\tthis: IExecuteFunctions,\n\tindex: number,\n): Promise<{ sessionId: string; windowId: string }> {\n\tconst node = this.getNode();\n\tconst profileName = validateProfileName.call(this, index);\n\tconst url = validateRequiredStringField.call(this, index, 'url', 'URL');\n\n\tconst { sessionId } = await createSession.call(this, {\n\t\tconfiguration: {\n\t\t\tprofileName,\n\t\t},\n\t});\n\n\tif (!sessionId) {\n\t\tthrow new NodeApiError(node, {\n\t\t\tmessage: 'Failed to create session',\n\t\t\tcode: 500,\n\t\t});\n\t}\n\tthis.logger.info(`[${node.name}] Session successfully created.`);\n\n\tconst windowResponse = await apiRequest.call(this, 'POST', `/sessions/${sessionId}/windows`, {\n\t\turl,\n\t});\n\tconst windowId = windowResponse?.data?.windowId as string;\n\n\tif (!windowId) {\n\t\tthrow new NodeApiError(node, {\n\t\t\tmessage: 'Failed to create window',\n\t\t\tcode: 500,\n\t\t});\n\t}\n\tthis.logger.info(`[${node.name}] Window successfully created.`);\n\treturn { sessionId, windowId };\n}\n"],"mappings":"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","names":["import_n8n_workflow"]}