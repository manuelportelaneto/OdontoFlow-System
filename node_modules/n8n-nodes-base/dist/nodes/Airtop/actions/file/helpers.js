"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var helpers_exports = {};
__export(helpers_exports, {
  createAndUploadFile: () => createAndUploadFile,
  createFileBuffer: () => createFileBuffer,
  pollFileUntilAvailable: () => pollFileUntilAvailable,
  pushFileToSession: () => pushFileToSession,
  requestAllFiles: () => requestAllFiles,
  triggerFileInput: () => triggerFileInput,
  waitForFileInSession: () => waitForFileInSession
});
module.exports = __toCommonJS(helpers_exports);
var import_n8n_workflow = require("n8n-workflow");
var import_constants = require("../../constants");
var import_transport = require("../../transport");
async function requestAllFiles(sessionIds) {
  const endpoint = "/files";
  let hasMore = true;
  let currentOffset = 0;
  const limit = 100;
  const files = [];
  let responseData;
  while (hasMore) {
    responseData = await import_transport.apiRequest.call(
      this,
      "GET",
      endpoint,
      {},
      { offset: currentOffset, limit, sessionIds }
    );
    if (responseData.data?.files && Array.isArray(responseData.data?.files)) {
      files.push(...responseData.data.files);
    }
    hasMore = Boolean(responseData.data?.pagination?.hasMore);
    currentOffset += limit;
  }
  return {
    data: {
      files,
      pagination: {
        hasMore
      }
    }
  };
}
async function pollFileUntilAvailable(fileId, timeout = import_constants.OPERATION_TIMEOUT, intervalSeconds = 1) {
  let fileStatus = "";
  const startTime = Date.now();
  while (fileStatus !== "available") {
    const elapsedTime = Date.now() - startTime;
    if (elapsedTime >= timeout) {
      throw new import_n8n_workflow.NodeApiError(this.getNode(), {
        message: import_constants.ERROR_MESSAGES.TIMEOUT_REACHED,
        code: 500
      });
    }
    const response = await import_transport.apiRequest.call(this, "GET", `/files/${fileId}`);
    fileStatus = response.data?.status;
    await new Promise((resolve) => setTimeout(resolve, intervalSeconds * 1e3));
  }
  return fileId;
}
async function createAndUploadFile(fileName, fileBuffer, fileType, pollingFunction = pollFileUntilAvailable) {
  const createResponse = await import_transport.apiRequest.call(this, "POST", "/files", { fileName, fileType });
  const fileId = createResponse.data?.id;
  const uploadUrl = createResponse.data?.uploadUrl;
  if (!fileId || !uploadUrl) {
    throw new import_n8n_workflow.NodeApiError(this.getNode(), {
      message: "Failed to create file entry: missing file ID or upload URL",
      code: 500
    });
  }
  await this.helpers.httpRequest({
    method: "PUT",
    url: uploadUrl,
    body: fileBuffer,
    headers: {
      "Content-Type": "application/octet-stream"
    }
  });
  return await pollingFunction.call(this, fileId);
}
function parseEvent(eventText) {
  const dataLine = eventText.split("\n").find((line) => line.startsWith("data:"));
  if (!dataLine) {
    return null;
  }
  const jsonStr = dataLine.replace("data: ", "").trim();
  return (0, import_n8n_workflow.jsonParse)(jsonStr, {
    errorMessage: "Failed to parse server event"
  });
}
function isFileAvailable(event, fileId) {
  return event.event === "file_upload_status" && event.fileId === fileId && event.status === "available";
}
async function waitForFileInSession(sessionId, fileId, timeout = import_constants.OPERATION_TIMEOUT) {
  const url = `${import_constants.BASE_URL}/sessions/${sessionId}/events?all=true`;
  const fileReadyPromise = new Promise(async (resolve, reject) => {
    const stream = await this.helpers.httpRequestWithAuthentication.call(this, "airtopApi", {
      method: "GET",
      url,
      encoding: "stream"
    });
    const close = () => {
      resolve();
      stream.removeAllListeners();
    };
    const onError = (errorMessage) => {
      const error = new import_n8n_workflow.NodeApiError(this.getNode(), {
        message: errorMessage,
        description: "Failed to upload file",
        code: 500
      });
      reject(error);
      stream.removeAllListeners();
    };
    stream.on("data", (data) => {
      const event = parseEvent(data.toString());
      if (!event) {
        return;
      }
      if (event?.eventData?.error) {
        onError(event.eventData.error);
        return;
      }
      if (isFileAvailable(event, fileId)) {
        close();
      }
    });
  });
  const timeoutPromise = new Promise((_resolve, reject) => {
    setTimeout(
      () => reject(
        new import_n8n_workflow.NodeApiError(this.getNode(), {
          message: import_constants.ERROR_MESSAGES.TIMEOUT_REACHED,
          code: 500
        })
      ),
      timeout
    );
  });
  await Promise.race([fileReadyPromise, timeoutPromise]);
}
async function pushFileToSession(fileId, sessionId, pollingFunction = waitForFileInSession) {
  await import_transport.apiRequest.call(this, "POST", `/files/${fileId}/push`, { sessionIds: [sessionId] });
  await pollingFunction.call(this, sessionId, fileId);
}
async function triggerFileInput(fileId, windowId, sessionId, elementDescription = "") {
  await import_transport.apiRequest.call(this, "POST", `/sessions/${sessionId}/windows/${windowId}/file-input`, {
    fileId,
    ...elementDescription ? { elementDescription } : {}
  });
}
async function createFileBuffer(source, value, itemIndex) {
  if (source === "url") {
    const buffer = await this.helpers.httpRequest({
      url: value,
      json: false,
      encoding: "arraybuffer"
    });
    return buffer;
  }
  if (source === "binary") {
    const binaryData = await this.helpers.getBinaryDataBuffer(itemIndex, value);
    return binaryData;
  }
  throw new import_n8n_workflow.NodeApiError(this.getNode(), {
    message: `Unsupported source type: ${source}. Please use 'url' or 'binary'`,
    code: 500
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createAndUploadFile,
  createFileBuffer,
  pollFileUntilAvailable,
  pushFileToSession,
  requestAllFiles,
  triggerFileInput,
  waitForFileInSession
});
//# sourceMappingURL=helpers.js.map