{"version":3,"sources":["../../../../../nodes/Airtop/actions/file/helpers.ts"],"sourcesContent":["import type { IExecuteFunctions } from 'n8n-workflow';\nimport { jsonParse, NodeApiError } from 'n8n-workflow';\nimport type { Stream } from 'stream';\n\nimport { BASE_URL, ERROR_MESSAGES, OPERATION_TIMEOUT } from '../../constants';\nimport { apiRequest } from '../../transport';\nimport type { IAirtopResponseWithFiles, IAirtopServerEvent } from '../../transport/types';\n\n/**\n * Fetches all files from the Airtop API using pagination\n * @param this - The execution context providing access to n8n functionality\n * @param sessionIds - Comma-separated string of session IDs to filter files by\n * @returns Promise resolving to a response object containing the complete array of files\n */\nexport async function requestAllFiles(\n\tthis: IExecuteFunctions,\n\tsessionIds: string,\n): Promise<IAirtopResponseWithFiles> {\n\tconst endpoint = '/files';\n\tlet hasMore = true;\n\tlet currentOffset = 0;\n\tconst limit = 100;\n\tconst files: IAirtopResponseWithFiles['data']['files'] = [];\n\tlet responseData: IAirtopResponseWithFiles;\n\n\twhile (hasMore) {\n\t\t// request files\n\t\tresponseData = (await apiRequest.call(\n\t\t\tthis,\n\t\t\t'GET',\n\t\t\tendpoint,\n\t\t\t{},\n\t\t\t{ offset: currentOffset, limit, sessionIds },\n\t\t)) as IAirtopResponseWithFiles;\n\t\t// add files to the array\n\t\tif (responseData.data?.files && Array.isArray(responseData.data?.files)) {\n\t\t\tfiles.push(...responseData.data.files);\n\t\t}\n\t\t// check if there are more files\n\t\thasMore = Boolean(responseData.data?.pagination?.hasMore);\n\t\tcurrentOffset += limit;\n\t}\n\n\treturn {\n\t\tdata: {\n\t\t\tfiles,\n\t\t\tpagination: {\n\t\t\t\thasMore,\n\t\t\t},\n\t\t},\n\t};\n}\n\n/**\n * Polls the Airtop API until a file reaches \"available\" status or times out\n * @param this - The execution context providing access to n8n functionality\n * @param fileId - The unique identifier of the file to poll\n * @param timeout - Maximum time in milliseconds to wait before failing (defaults to OPERATION_TIMEOUT)\n * @param intervalSeconds - Time in seconds to wait between polling attempts (defaults to 1)\n * @returns Promise resolving to the file ID when the file is available\n * @throws NodeApiError if the operation times out or API request fails\n */\nexport async function pollFileUntilAvailable(\n\tthis: IExecuteFunctions,\n\tfileId: string,\n\ttimeout = OPERATION_TIMEOUT,\n\tintervalSeconds = 1,\n): Promise<string> {\n\tlet fileStatus = '';\n\tconst startTime = Date.now();\n\n\twhile (fileStatus !== 'available') {\n\t\tconst elapsedTime = Date.now() - startTime;\n\t\tif (elapsedTime >= timeout) {\n\t\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\t\tmessage: ERROR_MESSAGES.TIMEOUT_REACHED,\n\t\t\t\tcode: 500,\n\t\t\t});\n\t\t}\n\n\t\tconst response = await apiRequest.call(this, 'GET', `/files/${fileId}`);\n\t\tfileStatus = response.data?.status as string;\n\n\t\t// Wait before the next polling attempt\n\t\tawait new Promise((resolve) => setTimeout(resolve, intervalSeconds * 1000));\n\t}\n\n\treturn fileId;\n}\n\n/**\n * Creates a file entry in Airtop, uploads the file content, and waits until processing completes\n * @param this - The execution context providing access to n8n functionality\n * @param fileName - Name to assign to the uploaded file\n * @param fileBuffer - Buffer containing the binary file data to upload\n * @param fileType - Classification of the file in Airtop (e.g., 'customer_upload')\n * @param pollingFunction - Function to use for checking file availability (defaults to pollFileUntilAvailable)\n * @returns Promise resolving to the file ID once upload is complete and file is available\n * @throws NodeApiError if file creation, upload, or polling fails\n */\nexport async function createAndUploadFile(\n\tthis: IExecuteFunctions,\n\tfileName: string,\n\tfileBuffer: Buffer,\n\tfileType: string,\n\tpollingFunction = pollFileUntilAvailable,\n): Promise<string> {\n\t// Create file entry\n\tconst createResponse = await apiRequest.call(this, 'POST', '/files', { fileName, fileType });\n\n\tconst fileId = createResponse.data?.id;\n\tconst uploadUrl = createResponse.data?.uploadUrl as string;\n\n\tif (!fileId || !uploadUrl) {\n\t\tthrow new NodeApiError(this.getNode(), {\n\t\t\tmessage: 'Failed to create file entry: missing file ID or upload URL',\n\t\t\tcode: 500,\n\t\t});\n\t}\n\n\t// Upload the file\n\tawait this.helpers.httpRequest({\n\t\tmethod: 'PUT',\n\t\turl: uploadUrl,\n\t\tbody: fileBuffer,\n\t\theaders: {\n\t\t\t'Content-Type': 'application/octet-stream',\n\t\t},\n\t});\n\n\t// Poll until the file is available\n\treturn await pollingFunction.call(this, fileId as string);\n}\n\nfunction parseEvent(eventText: string): IAirtopServerEvent | null {\n\tconst dataLine = eventText.split('\\n').find((line) => line.startsWith('data:'));\n\tif (!dataLine) {\n\t\treturn null;\n\t}\n\tconst jsonStr = dataLine.replace('data: ', '').trim();\n\treturn jsonParse<IAirtopServerEvent>(jsonStr, {\n\t\terrorMessage: 'Failed to parse server event',\n\t});\n}\n\nfunction isFileAvailable(event: IAirtopServerEvent, fileId: string): boolean {\n\treturn (\n\t\tevent.event === 'file_upload_status' && event.fileId === fileId && event.status === 'available'\n\t);\n}\n\n/**\n * Waits for a file to be ready in a session by monitoring session events\n * @param this - The execution context providing access to n8n functionality\n * @param sessionId - ID of the session to monitor for file events\n * @param timeout - Maximum time in milliseconds to wait before failing (defaults to OPERATION_TIMEOUT)\n * @returns Promise that resolves when a file in the session becomes available\n * @throws NodeApiError if the timeout is reached before a file becomes available\n */\nexport async function waitForFileInSession(\n\tthis: IExecuteFunctions,\n\tsessionId: string,\n\tfileId: string,\n\ttimeout = OPERATION_TIMEOUT,\n): Promise<void> {\n\tconst url = `${BASE_URL}/sessions/${sessionId}/events?all=true`;\n\n\tconst fileReadyPromise = new Promise<void>(async (resolve, reject) => {\n\t\tconst stream = (await this.helpers.httpRequestWithAuthentication.call(this, 'airtopApi', {\n\t\t\tmethod: 'GET',\n\t\t\turl,\n\t\t\tencoding: 'stream',\n\t\t})) as Stream;\n\n\t\tconst close = () => {\n\t\t\tresolve();\n\t\t\tstream.removeAllListeners();\n\t\t};\n\n\t\tconst onError = (errorMessage: string) => {\n\t\t\tconst error = new NodeApiError(this.getNode(), {\n\t\t\t\tmessage: errorMessage,\n\t\t\t\tdescription: 'Failed to upload file',\n\t\t\t\tcode: 500,\n\t\t\t});\n\t\t\treject(error);\n\t\t\tstream.removeAllListeners();\n\t\t};\n\n\t\tstream.on('data', (data: Uint8Array) => {\n\t\t\tconst event = parseEvent(data.toString());\n\t\t\tif (!event) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// handle error\n\t\t\tif (event?.eventData?.error) {\n\t\t\t\tonError(event.eventData.error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// handle file available\n\t\t\tif (isFileAvailable(event, fileId)) {\n\t\t\t\tclose();\n\t\t\t}\n\t\t});\n\t});\n\n\tconst timeoutPromise = new Promise<void>((_resolve, reject) => {\n\t\tsetTimeout(\n\t\t\t() =>\n\t\t\t\treject(\n\t\t\t\t\tnew NodeApiError(this.getNode(), {\n\t\t\t\t\t\tmessage: ERROR_MESSAGES.TIMEOUT_REACHED,\n\t\t\t\t\t\tcode: 500,\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\ttimeout,\n\t\t);\n\t});\n\n\tawait Promise.race([fileReadyPromise, timeoutPromise]);\n}\n\n/**\n * Associates a file with a session and waits until the file is ready for use\n * @param this - The execution context providing access to n8n functionality\n * @param fileId - ID of the file to associate with the session\n * @param sessionId - ID of the session to add the file to\n * @param pollingFunction - Function to use for checking file availability in session (defaults to waitForFileInSession)\n * @returns Promise that resolves when the file is ready for use in the session\n */\nexport async function pushFileToSession(\n\tthis: IExecuteFunctions,\n\tfileId: string,\n\tsessionId: string,\n\tpollingFunction = waitForFileInSession,\n): Promise<void> {\n\t// Push file into session\n\tawait apiRequest.call(this, 'POST', `/files/${fileId}/push`, { sessionIds: [sessionId] });\n\tawait pollingFunction.call(this, sessionId, fileId);\n}\n\n/**\n * Activates a file upload input in a specific window within a session\n * @param this - The execution context providing access to n8n functionality\n * @param fileId - ID of the file to use for the input\n * @param windowId - ID of the window where the file input will be triggered\n * @param sessionId - ID of the session containing the window\n * @returns Promise that resolves when the file input has been triggered\n */\nexport async function triggerFileInput(\n\tthis: IExecuteFunctions,\n\tfileId: string,\n\twindowId: string,\n\tsessionId: string,\n\telementDescription = '',\n): Promise<void> {\n\tawait apiRequest.call(this, 'POST', `/sessions/${sessionId}/windows/${windowId}/file-input`, {\n\t\tfileId,\n\t\t...(elementDescription ? { elementDescription } : {}),\n\t});\n}\n\n/**\n * Creates a file Buffer from either a URL or binary data\n * This function supports two source types:\n * - URL: Downloads the file from the specified URL and returns it as a Buffer\n * - Binary: Retrieves binary data from the workflow's binary data storage\n *\n * @param this - The execution context providing access to n8n functionality\n * @param source - Source type, either 'url' or 'binary'\n * @param value - Either a URL string or binary data property name depending on source type\n * @param itemIndex - Index of the workflow item to get binary data from (when source is 'binary')\n * @returns Promise resolving to a Buffer containing the file data\n * @throws NodeApiError if the source type is unsupported or retrieval fails\n */\nexport async function createFileBuffer(\n\tthis: IExecuteFunctions,\n\tsource: string,\n\tvalue: string,\n\titemIndex: number,\n): Promise<Buffer> {\n\tif (source === 'url') {\n\t\tconst buffer = (await this.helpers.httpRequest({\n\t\t\turl: value,\n\t\t\tjson: false,\n\t\t\tencoding: 'arraybuffer',\n\t\t})) as Buffer;\n\n\t\treturn buffer;\n\t}\n\n\tif (source === 'binary') {\n\t\tconst binaryData = await this.helpers.getBinaryDataBuffer(itemIndex, value);\n\t\treturn binaryData;\n\t}\n\n\tthrow new NodeApiError(this.getNode(), {\n\t\tmessage: `Unsupported source type: ${source}. Please use 'url' or 'binary'`,\n\t\tcode: 500,\n\t});\n}\n"],"mappings":"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","names":[]}