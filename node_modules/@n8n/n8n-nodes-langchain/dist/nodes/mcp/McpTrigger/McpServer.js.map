{"version":3,"sources":["../../../../nodes/mcp/McpTrigger/McpServer.ts"],"sourcesContent":["import type { Tool } from '@langchain/core/tools';\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport type { RequestHandlerExtra } from '@modelcontextprotocol/sdk/shared/protocol.js';\nimport type {\n\tJSONRPCMessage,\n\tServerRequest,\n\tServerNotification,\n} from '@modelcontextprotocol/sdk/types.js';\nimport {\n\tJSONRPCMessageSchema,\n\tListToolsRequestSchema,\n\tCallToolRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport type * as express from 'express';\nimport { OperationalError, type Logger } from 'n8n-workflow';\nimport { zodToJsonSchema } from 'zod-to-json-schema';\n\nimport { FlushingSSEServerTransport } from './FlushingSSEServerTransport';\nimport type { CompressionResponse } from './FlushingSSEServerTransport';\n\n/**\n * Parses the JSONRPC message and checks whether the method used was a tool\n * call. This is necessary in order to not have executions for listing tools\n * and other commands sent by the MCP client\n */\nfunction wasToolCall(body: string) {\n\ttry {\n\t\tconst message: unknown = JSON.parse(body);\n\t\tconst parsedMessage: JSONRPCMessage = JSONRPCMessageSchema.parse(message);\n\t\treturn (\n\t\t\t'method' in parsedMessage &&\n\t\t\t'id' in parsedMessage &&\n\t\t\tparsedMessage?.method === CallToolRequestSchema.shape.method.value\n\t\t);\n\t} catch {\n\t\treturn false;\n\t}\n}\n\n/**\n * Extracts the request ID from a JSONRPC message (for example for tool calls).\n * Returns undefined if the message doesn't have an ID (for example on a tool list request)\n *\n */\nfunction getRequestId(body: string): string | undefined {\n\ttry {\n\t\tconst message: unknown = JSON.parse(body);\n\t\tconst parsedMessage: JSONRPCMessage = JSONRPCMessageSchema.parse(message);\n\t\treturn 'id' in parsedMessage ? String(parsedMessage.id) : undefined;\n\t} catch {\n\t\treturn undefined;\n\t}\n}\n\n/**\n * This singleton is shared across the instance, making sure it is the one\n * keeping account of MCP servers.\n * It needs to stay in memory to keep track of the long-lived connections.\n * It requires a logger at first creation to set everything up.\n */\nexport class McpServerManager {\n\tstatic #instance: McpServerManager;\n\n\tservers: { [sessionId: string]: Server } = {};\n\n\ttransports: { [sessionId: string]: FlushingSSEServerTransport } = {};\n\n\tprivate tools: { [sessionId: string]: Tool[] } = {};\n\n\tprivate resolveFunctions: { [callId: string]: CallableFunction } = {};\n\n\tlogger: Logger;\n\n\tprivate constructor(logger: Logger) {\n\t\tthis.logger = logger;\n\t\tthis.logger.debug('MCP Server created');\n\t}\n\n\tstatic instance(logger: Logger): McpServerManager {\n\t\tif (!McpServerManager.#instance) {\n\t\t\tMcpServerManager.#instance = new McpServerManager(logger);\n\t\t\tlogger.debug('Created singleton MCP manager');\n\t\t}\n\n\t\treturn McpServerManager.#instance;\n\t}\n\n\tasync createServerAndTransport(\n\t\tserverName: string,\n\t\tpostUrl: string,\n\t\tresp: CompressionResponse,\n\t): Promise<void> {\n\t\tconst transport = new FlushingSSEServerTransport(postUrl, resp);\n\t\tconst server = new Server(\n\t\t\t{\n\t\t\t\tname: serverName,\n\t\t\t\tversion: '0.1.0',\n\t\t\t},\n\t\t\t{\n\t\t\t\tcapabilities: { tools: {} },\n\t\t\t},\n\t\t);\n\n\t\tthis.setUpHandlers(server);\n\t\tconst { sessionId } = transport;\n\t\tthis.transports[sessionId] = transport;\n\t\tthis.servers[sessionId] = server;\n\n\t\tresp.on('close', async () => {\n\t\t\tthis.logger.debug(`Deleting transport for ${sessionId}`);\n\t\t\tdelete this.tools[sessionId];\n\t\t\tdelete this.transports[sessionId];\n\t\t\tdelete this.servers[sessionId];\n\t\t});\n\n\t\tawait server.connect(transport);\n\n\t\t// Make sure we flush the compression middleware, so that it's not waiting for more content to be added to the buffer\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\t}\n\n\tasync handlePostMessage(req: express.Request, resp: CompressionResponse, connectedTools: Tool[]) {\n\t\tconst sessionId = req.query.sessionId as string;\n\t\tconst transport = this.transports[sessionId];\n\t\tif (transport) {\n\t\t\t// We need to add a promise here because the `handlePostMessage` will send something to the\n\t\t\t// MCP Server, that will run in a different context. This means that the return will happen\n\t\t\t// almost immediately, and will lead to marking the sub-node as \"running\" in the final execution\n\t\t\tconst bodyString = req.rawBody.toString();\n\t\t\tconst messageId = getRequestId(bodyString);\n\n\t\t\t// Use session & message ID if available, otherwise fall back to sessionId\n\t\t\tconst callId = messageId ? `${sessionId}_${messageId}` : sessionId;\n\t\t\tthis.tools[sessionId] = connectedTools;\n\n\t\t\ttry {\n\t\t\t\tawait new Promise(async (resolve) => {\n\t\t\t\t\tthis.resolveFunctions[callId] = resolve;\n\t\t\t\t\tawait transport.handlePostMessage(req, resp, bodyString);\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\tdelete this.resolveFunctions[callId];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.logger.warn(`No transport found for session ${sessionId}`);\n\t\t\tresp.status(401).send('No transport found for sessionId');\n\t\t}\n\n\t\tif (resp.flush) {\n\t\t\tresp.flush();\n\t\t}\n\n\t\treturn wasToolCall(req.rawBody.toString());\n\t}\n\n\tsetUpHandlers(server: Server) {\n\t\tserver.setRequestHandler(\n\t\t\tListToolsRequestSchema,\n\t\t\tasync (_, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => {\n\t\t\t\tif (!extra.sessionId) {\n\t\t\t\t\tthrow new OperationalError('Require a sessionId for the listing of tools');\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\ttools: this.tools[extra.sessionId].map((tool) => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tname: tool.name,\n\t\t\t\t\t\t\tdescription: tool.description,\n\t\t\t\t\t\t\t// Allow additional properties on tool call input\n\t\t\t\t\t\t\tinputSchema: zodToJsonSchema(tool.schema, { removeAdditionalStrategy: 'strict' }),\n\t\t\t\t\t\t};\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t},\n\t\t);\n\n\t\tserver.setRequestHandler(\n\t\t\tCallToolRequestSchema,\n\t\t\tasync (request, extra: RequestHandlerExtra<ServerRequest, ServerNotification>) => {\n\t\t\t\tif (!request.params?.name || !request.params?.arguments) {\n\t\t\t\t\tthrow new OperationalError('Require a name and arguments for the tool call');\n\t\t\t\t}\n\t\t\t\tif (!extra.sessionId) {\n\t\t\t\t\tthrow new OperationalError('Require a sessionId for the tool call');\n\t\t\t\t}\n\n\t\t\t\tconst callId = extra.requestId ? `${extra.sessionId}_${extra.requestId}` : extra.sessionId;\n\n\t\t\t\tconst requestedTool: Tool | undefined = this.tools[extra.sessionId].find(\n\t\t\t\t\t(tool) => tool.name === request.params.name,\n\t\t\t\t);\n\t\t\t\tif (!requestedTool) {\n\t\t\t\t\tthrow new OperationalError('Tool not found');\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await requestedTool.invoke(request.params.arguments);\n\t\t\t\t\tif (this.resolveFunctions[callId]) {\n\t\t\t\t\t\tthis.resolveFunctions[callId]();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.logger.warn(`No resolve function found for ${callId}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.logger.debug(`Got request for ${requestedTool.name}, and executed it.`);\n\n\t\t\t\t\tif (typeof result === 'object') {\n\t\t\t\t\t\treturn { content: [{ type: 'text', text: JSON.stringify(result) }] };\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn { content: [{ type: 'text', text: result }] };\n\t\t\t\t\t}\n\t\t\t\t\treturn { content: [{ type: 'text', text: String(result) }] };\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.logger.error(`Error while executing Tool ${requestedTool.name}: ${error}`);\n\t\t\t\t\treturn { isError: true, content: [{ type: 'text', text: `Error: ${error.message}` }] };\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\n\t\tserver.onclose = () => {\n\t\t\tthis.logger.debug('Closing MCP Server');\n\t\t};\n\t\tserver.onerror = (error: unknown) => {\n\t\t\tthis.logger.error(`MCP Error: ${error}`);\n\t\t};\n\t}\n}\n"],"mappings":"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","names":[]}