"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var VectorStoreMongoDBAtlas_node_exports = {};
__export(VectorStoreMongoDBAtlas_node_exports, {
  VectorStoreMongoDBAtlas: () => VectorStoreMongoDBAtlas
});
module.exports = __toCommonJS(VectorStoreMongoDBAtlas_node_exports);
var import_mongodb = require("@langchain/mongodb");
var import_mongodb2 = require("mongodb");
var import_n8n_workflow = require("n8n-workflow");
var import_sharedFields = require("../../../utils/sharedFields");
var import_createVectorStoreNode = require("../shared/createVectorStoreNode/createVectorStoreNode");
const mongoCollectionRLC = {
  displayName: "MongoDB Collection",
  name: "mongoCollection",
  type: "resourceLocator",
  default: { mode: "list", value: "" },
  required: true,
  modes: [
    {
      displayName: "From List",
      name: "list",
      type: "list",
      typeOptions: {
        searchListMethod: "mongoCollectionSearch"
        // Method to fetch collections
      }
    },
    {
      displayName: "Name",
      name: "name",
      type: "string",
      placeholder: "e.g. my_collection"
    }
  ]
};
const vectorIndexName = {
  displayName: "Vector Index Name",
  name: "vectorIndexName",
  type: "string",
  default: "",
  description: "The name of the vector index",
  required: true
};
const embeddingField = {
  displayName: "Embedding",
  name: "embedding",
  type: "string",
  default: "embedding",
  description: "The field with the embedding array",
  required: true
};
const metadataField = {
  displayName: "Metadata Field",
  name: "metadata_field",
  type: "string",
  default: "text",
  description: "The text field of the raw data",
  required: true
};
const sharedFields = [
  mongoCollectionRLC,
  embeddingField,
  metadataField,
  vectorIndexName
];
const mongoNamespaceField = {
  displayName: "Namespace",
  name: "namespace",
  type: "string",
  description: "Logical partition for documents. Uses metadata.namespace field for filtering.",
  default: ""
};
const retrieveFields = [
  {
    displayName: "Options",
    name: "options",
    type: "collection",
    placeholder: "Add Option",
    default: {},
    options: [mongoNamespaceField, import_sharedFields.metadataFilterField]
  }
];
const insertFields = [
  {
    displayName: "Options",
    name: "options",
    type: "collection",
    placeholder: "Add Option",
    default: {},
    options: [
      {
        displayName: "Clear Namespace",
        name: "clearNamespace",
        type: "boolean",
        default: false,
        description: "Whether to clear documents in the namespace before inserting new data"
      },
      mongoNamespaceField
    ]
  }
];
let mongoClient = null;
async function getMongoClient(context) {
  if (!mongoClient) {
    const credentials = await context.getCredentials("mongoDb");
    mongoClient = new import_mongodb2.MongoClient(credentials.connectionString, {
      appName: "devrel.integration.n8n_vector_integ"
    });
    await mongoClient.connect();
  }
  return mongoClient;
}
async function mongoClientAndDatabase(context) {
  const client = await getMongoClient(context);
  const credentials = await context.getCredentials("mongoDb");
  const db = client.db(credentials.database);
  return { client, db };
}
async function mongoCollectionSearch() {
  const { db } = await mongoClientAndDatabase(this);
  try {
    const collections = await db.listCollections().toArray();
    const results = collections.map((collection) => ({
      name: collection.name,
      value: collection.name
    }));
    return { results };
  } catch (error) {
    throw new import_n8n_workflow.NodeOperationError(this.getNode(), `Error: ${error.message}`);
  }
}
class VectorStoreMongoDBAtlas extends (0, import_createVectorStoreNode.createVectorStoreNode)({
  meta: {
    displayName: "MongoDB Atlas Vector Store",
    name: "vectorStoreMongoDBAtlas",
    description: "Work with your data in MongoDB Atlas Vector Store",
    icon: { light: "file:mongodb.svg", dark: "file:mongodb.dark.svg" },
    docsUrl: "https://docs.n8n.io/integrations/builtin/cluster-nodes/root-nodes/n8n-nodes-langchain.vectorstoremongodbatlas/",
    credentials: [
      {
        name: "mongoDb",
        required: true
      }
    ],
    operationModes: ["load", "insert", "retrieve", "update", "retrieve-as-tool"]
  },
  methods: { listSearch: { mongoCollectionSearch } },
  retrieveFields,
  loadFields: retrieveFields,
  insertFields,
  sharedFields,
  async getVectorStoreClient(context, _filter, embeddings, itemIndex) {
    try {
      const { db } = await mongoClientAndDatabase(context);
      try {
        const collectionName = context.getNodeParameter("mongoCollection", itemIndex, "", {
          extractValue: true
        });
        const mongoVectorIndexName = context.getNodeParameter("vectorIndexName", itemIndex, "", {
          extractValue: true
        });
        const embeddingFieldName = context.getNodeParameter("embedding", itemIndex, "", {
          extractValue: true
        });
        const metadataFieldName = context.getNodeParameter("metadata_field", itemIndex, "", {
          extractValue: true
        });
        const collection = db.collection(collectionName);
        const indexes = await collection.listSearchIndexes().toArray();
        const indexExists = indexes.some((index) => index.name === mongoVectorIndexName);
        if (!indexExists) {
          throw new import_n8n_workflow.NodeOperationError(
            context.getNode(),
            `Index ${mongoVectorIndexName} not found`,
            {
              itemIndex,
              description: "Please check that the index exists in your collection"
            }
          );
        }
        return new import_mongodb.MongoDBAtlasVectorSearch(embeddings, {
          collection,
          indexName: mongoVectorIndexName,
          // Default index name
          textKey: metadataFieldName,
          // Field containing raw text
          embeddingKey: embeddingFieldName
          // Field containing embeddings
        });
      } catch (error) {
        throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
          itemIndex,
          description: "Please check your MongoDB Atlas connection details"
        });
      } finally {
      }
    } catch (error) {
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
        itemIndex,
        description: "Please check your MongoDB Atlas connection details"
      });
    }
  },
  async populateVectorStore(context, embeddings, documents, itemIndex) {
    try {
      const { db } = await mongoClientAndDatabase(context);
      try {
        const mongoCollectionName = context.getNodeParameter("mongoCollection", itemIndex, "", {
          extractValue: true
        });
        const embeddingFieldName = context.getNodeParameter("embedding", itemIndex, "", {
          extractValue: true
        });
        const metadataFieldName = context.getNodeParameter("metadata_field", itemIndex, "", {
          extractValue: true
        });
        const mongoDBAtlasVectorIndex = context.getNodeParameter("vectorIndexName", itemIndex, "", {
          extractValue: true
        });
        const collections = await db.listCollections({ name: mongoCollectionName }).toArray();
        if (collections.length === 0) {
          await db.createCollection(mongoCollectionName);
        }
        const collection = db.collection(mongoCollectionName);
        await import_mongodb.MongoDBAtlasVectorSearch.fromDocuments(documents, embeddings, {
          collection,
          indexName: mongoDBAtlasVectorIndex,
          // Default index name
          textKey: metadataFieldName,
          // Field containing raw text
          embeddingKey: embeddingFieldName
          // Field containing embeddings
        });
      } catch (error) {
        throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
          itemIndex,
          description: "Please check your MongoDB Atlas connection details"
        });
      } finally {
      }
    } catch (error) {
      throw new import_n8n_workflow.NodeOperationError(context.getNode(), `Error: ${error.message}`, {
        itemIndex,
        description: "Please check your MongoDB Atlas connection details"
      });
    }
  }
}) {
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VectorStoreMongoDBAtlas
});
//# sourceMappingURL=VectorStoreMongoDBAtlas.node.js.map