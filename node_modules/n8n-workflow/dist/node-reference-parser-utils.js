"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasDotNotationBannedChar = hasDotNotationBannedChar;
exports.backslashEscape = backslashEscape;
exports.dollarEscape = dollarEscape;
exports.applyAccessPatterns = applyAccessPatterns;
exports.extractReferencesInNodeExpressions = extractReferencesInNodeExpressions;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const escapeRegExp_1 = __importDefault(require("lodash/escapeRegExp"));
const isEqual_1 = __importDefault(require("lodash/isEqual"));
const mapValues_1 = __importDefault(require("lodash/mapValues"));
const errors_1 = require("./errors");
class LazyRegExp {
    constructor(pattern, flags) {
        this.pattern = pattern;
        this.flags = flags;
    }
    get() {
        if (!this.regExp)
            this.regExp = new RegExp(this.pattern(), this.flags);
        return this.regExp;
    }
}
const DOT_REFERENCEABLE_JS_VARIABLE = /\w[\w\d_\$]*/;
const INVALID_JS_DOT_PATH = /[^\.\w\d_\$]/;
const INVALID_JS_DOT_NAME = /[^\w\d_\$]/;
const ITEM_TO_DATA_ACCESSORS = [
    /^first\(\)/,
    /^last\(\)/,
    /^all\(\)/,
    /^itemMatching\(\d+\)/,
    /^item/,
];
const ITEM_ACCESSORS = ['params', 'isExecuted'];
const DATA_ACCESSORS = ['json', 'binary'];
function hasDotNotationBannedChar(nodeName) {
    const DOT_NOTATION_BANNED_CHARS = /^(\d)|[\\ `!@#$%^&*()_+\-=[\]{};':"\\|,.<>?~]/g;
    return DOT_NOTATION_BANNED_CHARS.test(nodeName);
}
function backslashEscape(nodeName) {
    const BACKSLASH_ESCAPABLE_CHARS = /[.*+?^${}()|[\]\\]/g;
    return nodeName.replace(BACKSLASH_ESCAPABLE_CHARS, (char) => `\\${char}`);
}
function dollarEscape(nodeName) {
    return nodeName.replace(new RegExp('\\$', 'g'), '$$$$');
}
const ACCESS_PATTERNS = [
    {
        checkPattern: '$(',
        replacePattern: (s) => String.raw `(\$\(['"])${s}(['"]\))`,
    },
    {
        checkPattern: '$node[',
        replacePattern: (s) => String.raw `(\$node\[['"])${s}(['"]\])`,
    },
    {
        checkPattern: '$node.',
        replacePattern: (s) => String.raw `(\$node\.)${s}(\.?)`,
        customCallback: (expression, newName, escapedNewName) => {
            if (hasDotNotationBannedChar(newName)) {
                const regex = new RegExp(`.${backslashEscape(newName)}( |\\.)`, 'g');
                return expression.replace(regex, `["${escapedNewName}"]$1`);
            }
            return expression;
        },
    },
    {
        checkPattern: '$items(',
        replacePattern: (s) => String.raw `(\$items\(['"])${s}(['"],|['"]\))`,
    },
];
function applyAccessPatterns(expression, previousName, newName) {
    if (!expression.includes(previousName))
        return expression;
    const escapedOldName = backslashEscape(previousName);
    const escapedNewName = dollarEscape(newName);
    for (const pattern of ACCESS_PATTERNS) {
        if (expression.includes(pattern.checkPattern)) {
            expression = expression.replace(new RegExp(pattern.replacePattern(escapedOldName), 'g'), `$1${escapedNewName}$2`);
            if (pattern.customCallback) {
                expression = pattern.customCallback(expression, newName, escapedNewName);
            }
        }
    }
    return expression;
}
function convertToUniqueJsDotName(nodeName, allNodeNames) {
    let jsLegal = nodeName
        .replaceAll(' ', '_')
        .split('')
        .filter((x) => !INVALID_JS_DOT_NAME.test(x))
        .join('');
    if (nodeName === jsLegal)
        return jsLegal;
    while (allNodeNames.includes(jsLegal))
        jsLegal += `_${allNodeNames.indexOf(nodeName)}`;
    return jsLegal;
}
function convertDataAccessorName(name) {
    const [fnName, maybeDigits] = name.split('(');
    switch (fnName.toLowerCase()) {
        case 'item':
            return fnName;
        case 'first':
        case 'last':
            return `${fnName}Item`;
        case 'all':
            return `${fnName}Items`;
    }
    return `${fnName}_${maybeDigits?.slice(0, -1) ?? 'unknown'}`;
}
function parseExpressionMapping(isolatedExpression, nodeNameInExpression, nodeNamePlainJs, startNodeName) {
    const splitExpr = isolatedExpression.split('.');
    const dotsInName = nodeNameInExpression?.split('').filter((x) => x === '.').length ?? 0;
    const dotInAccessorsOffset = isolatedExpression.startsWith('$node.') ? 1 : 0;
    const exprStart = splitExpr.slice(0, dotInAccessorsOffset + dotsInName + 1).join('.');
    const parts = splitExpr.slice(dotInAccessorsOffset + dotsInName + 1);
    if (exprStart === '$json') {
        let partsIdx = 0;
        for (; partsIdx < parts.length; ++partsIdx) {
            if (!DOT_REFERENCEABLE_JS_VARIABLE.test(parts[partsIdx]))
                break;
        }
        return {
            nodeNameInExpression: null,
            originalExpression: `${exprStart}.${parts.slice(0, partsIdx + 1).join('.')}`,
            replacementPrefix: `${exprStart}`,
            replacementName: `${parts.slice(0, partsIdx).join('_')}`,
        };
    }
    if (parts.length === 0) {
        return null;
    }
    const accessorPrefix = parts[0] === 'all()' ? 'first()' : parts[0];
    if (ITEM_TO_DATA_ACCESSORS.some((x) => parts[0].match(x))) {
        if (parts.length === 1) {
            const originalName = parts[0];
            return {
                nodeNameInExpression,
                originalExpression: `${exprStart}.${parts[0]}`,
                replacementPrefix: `$('${startNodeName}').${accessorPrefix}.json`,
                replacementName: `${nodeNamePlainJs}_${convertDataAccessorName(originalName)}`,
            };
        }
        else {
            if (DATA_ACCESSORS.some((x) => parts[1] === x)) {
                let partsIdx = 2;
                for (; partsIdx < parts.length; ++partsIdx) {
                    if (!DOT_REFERENCEABLE_JS_VARIABLE.test(parts[partsIdx]))
                        break;
                }
                const replacementPostfix = parts[0] === 'item' ? '' : `_${convertDataAccessorName(parts[0])}`;
                return {
                    nodeNameInExpression,
                    originalExpression: `${exprStart}.${parts.slice(0, partsIdx + 1).join('.')}`,
                    replacementPrefix: `$('${startNodeName}').${accessorPrefix}.${parts[1]}`,
                    replacementName: parts.slice(2, partsIdx).join('_') + replacementPostfix,
                };
            }
            else {
                return {
                    nodeNameInExpression,
                    originalExpression: `${exprStart}.${parts[0]}`,
                    replacementPrefix: `$('${startNodeName}').${accessorPrefix}.json`,
                    replacementName: `${nodeNamePlainJs}_${convertDataAccessorName(parts[0])}`,
                };
            }
        }
    }
    const itemAccessorMatch = ITEM_ACCESSORS.flatMap((x) => (x === parts[0] ? x : []))[0];
    if (itemAccessorMatch !== undefined) {
        return {
            nodeNameInExpression,
            originalExpression: `${exprStart}.${parts[0]}`,
            replacementPrefix: `$('${startNodeName}').first().json`,
            replacementName: `${nodeNamePlainJs}_${parts[0]}`,
        };
    }
    return null;
}
function extractExpressionCandidate(expression, startIndex, endIndex) {
    const firstPartException = ITEM_TO_DATA_ACCESSORS.map((x) => x.exec(expression.slice(endIndex))).filter((x) => x !== null);
    let after_accessor_idx = endIndex + (firstPartException[0]?.[0].length ?? -1);
    if (expression[after_accessor_idx + 1] === '.')
        after_accessor_idx += 1;
    const after_accessor = expression.slice(after_accessor_idx);
    const firstInvalidCharMatch = INVALID_JS_DOT_PATH.exec(after_accessor);
    if (!firstInvalidCharMatch)
        return null;
    return expression.slice(startIndex, after_accessor_idx + firstInvalidCharMatch.index);
}
function parseCandidateMatch(match, expression, nodeNames, startNodeName) {
    const startIndex = match.index;
    const endIndex = startIndex + match[0].length + 1;
    const nodeNameInExpression = match[2];
    if (!nodeNames.includes(nodeNameInExpression))
        return null;
    const candidate = extractExpressionCandidate(expression, startIndex, endIndex);
    if (candidate === null)
        return null;
    return parseExpressionMapping(candidate, nodeNameInExpression, convertToUniqueJsDotName(nodeNameInExpression, nodeNames), startNodeName);
}
function parse$jsonMatch(match, expression, startNodeName) {
    const candidate = extractExpressionCandidate(expression, match.index, match.index + match[0].length + 1);
    if (candidate === null)
        return null;
    return parseExpressionMapping(candidate, null, null, startNodeName);
}
function parseReferencingExpressions(expression, nodeRegexps, nodeNames, startNodeName, parse$json) {
    const result = [];
    for (const [pattern, regexp] of nodeRegexps) {
        if (!expression.includes(pattern))
            continue;
        const matches = [...expression.matchAll(regexp.get())];
        result.push(...matches
            .map((x) => parseCandidateMatch(x, expression, nodeNames, startNodeName))
            .filter((x) => x !== null));
    }
    if (parse$json && expression.includes('$json')) {
        for (const match of expression.matchAll(/\$json/gi)) {
            const res = parse$jsonMatch(match, expression, startNodeName);
            if (res)
                result.push(res);
        }
    }
    return result;
}
function applyParameterMapping(parameterValue, mapper, keyOfValue) {
    const result = {};
    if (typeof parameterValue !== 'object' || parameterValue === null) {
        if (typeof parameterValue === 'string' &&
            (parameterValue.charAt(0) === '=' || keyOfValue === 'jsCode')) {
            const mapping = mapper(parameterValue);
            return [mapping, mapping];
        }
        return [undefined, []];
    }
    const allMappings = [];
    for (const [key, value] of Object.entries(parameterValue)) {
        const [mapping, all] = applyParameterMapping(value, mapper, key);
        result[key] = mapping;
        allMappings.push(...all);
    }
    return [result, allMappings];
}
function resolveDuplicates(data, allNodeNames) {
    const triggerArgumentMap = new Map();
    const originalExpressionMap = new Map();
    for (const mapping of data) {
        const { nodeNameInExpression, originalExpression, replacementPrefix } = mapping;
        let { replacementName } = mapping;
        const hasKeyAndCollides = (key) => {
            const value = triggerArgumentMap.get(key);
            if (!value)
                return false;
            return !(0, isEqual_1.default)(value, mapping);
        };
        const key = () => `${replacementPrefix}.${replacementName}`;
        if (hasKeyAndCollides(key()) && nodeNameInExpression) {
            replacementName = `${convertToUniqueJsDotName(nodeNameInExpression, allNodeNames)}_${replacementName}`;
        }
        while (hasKeyAndCollides(key()))
            replacementName += '_1';
        triggerArgumentMap.set(key(), {
            originalExpression,
            nodeNameInExpression,
            replacementName,
            replacementPrefix,
        });
        originalExpressionMap.set(originalExpression, key());
    }
    return {
        triggerArgumentMap,
        originalExpressionMap,
    };
}
function applyExtractMappingToNode(node, parameterExtractMapping) {
    const usedMappings = [];
    const applyMapping = (parameters, mapping) => {
        if (!mapping)
            return parameters;
        if (typeof parameters !== 'object' || parameters === null) {
            if (Array.isArray(mapping) && typeof parameters === 'string') {
                for (const mapper of mapping) {
                    if (!parameters.includes(mapper.originalExpression))
                        continue;
                    parameters = parameters.replaceAll(mapper.originalExpression, `${mapper.replacementPrefix}.${mapper.replacementName}`);
                    usedMappings.push(mapper);
                }
            }
            return parameters;
        }
        if (Array.isArray(mapping)) {
            return parameters;
        }
        if (Array.isArray(parameters) && typeof mapping === 'object' && !Array.isArray(mapping)) {
            return parameters.map((x, i) => applyMapping(x, mapping[i]));
        }
        return (0, mapValues_1.default)(parameters, (v, k) => applyMapping(v, mapping[k]));
    };
    const parameters = applyMapping(node.parameters, parameterExtractMapping);
    return { result: { ...node, parameters }, usedMappings };
}
function applyCanonicalMapping(mapping, getCanonicalData) {
    if (!mapping)
        return;
    if (Array.isArray(mapping)) {
        return mapping
            .map(getCanonicalData)
            .filter((x) => x !== undefined)
            .sort((a, b) => b.originalExpression.length - a.originalExpression.length);
    }
    return (0, mapValues_1.default)(mapping, (v) => applyCanonicalMapping(v, getCanonicalData));
}
function extractReferencesInNodeExpressions(subGraph, nodeNames, insertedStartName, graphInputNodeNames) {
    const subGraphNames = subGraph.map((x) => x.name);
    if (subGraphNames.includes(insertedStartName))
        throw new errors_1.OperationalError(`StartNodeName ${insertedStartName} already exists in nodeNames: ${JSON.stringify(subGraphNames)}`);
    if (subGraphNames.some((x) => !nodeNames.includes(x))) {
        throw new errors_1.OperationalError(`extractReferencesInNodeExpressions called with node in subGraph ${JSON.stringify(subGraphNames)} whose name is not in provided 'nodeNames' list ${JSON.stringify(nodeNames)}.`);
    }
    const namesRegexp = '(' + nodeNames.map(escapeRegExp_1.default).join('|') + ')';
    const nodeRegexps = ACCESS_PATTERNS.map((pattern) => [
        pattern.checkPattern,
        new LazyRegExp(() => pattern.replacePattern(namesRegexp), 'g'),
    ]);
    const parameterTreeMappingByNode = new Map();
    const allData = [];
    for (const node of subGraph) {
        const [parameterMapping, allMappings] = applyParameterMapping(node.parameters, (s) => parseReferencingExpressions(s, nodeRegexps, nodeNames, insertedStartName, graphInputNodeNames?.includes(node.name) ?? false));
        parameterTreeMappingByNode.set(node.name, parameterMapping);
        allData.push(...allMappings);
    }
    const subGraphNodeNames = new Set(subGraphNames);
    const dataFromOutsideSubgraph = allData.filter((x) => !x.nodeNameInExpression || !subGraphNodeNames.has(x.nodeNameInExpression));
    const { originalExpressionMap, triggerArgumentMap } = resolveDuplicates(dataFromOutsideSubgraph, nodeNames);
    const getCanonicalData = (e) => {
        const key = originalExpressionMap.get(e.originalExpression);
        if (!key)
            return undefined;
        return triggerArgumentMap.get(key);
    };
    for (const [key, value] of parameterTreeMappingByNode.entries()) {
        parameterTreeMappingByNode.set(key, applyCanonicalMapping(value, getCanonicalData));
    }
    const allUsedMappings = [];
    const output = [];
    for (const node of subGraph) {
        const { result, usedMappings } = applyExtractMappingToNode((0, cloneDeep_1.default)(node), parameterTreeMappingByNode.get(node.name));
        allUsedMappings.push(...usedMappings);
        output.push(result);
    }
    const variables = new Map(allUsedMappings.map((m) => [m.replacementName, m.originalExpression]));
    return { nodes: output, variables };
}
//# sourceMappingURL=node-reference-parser-utils.js.map